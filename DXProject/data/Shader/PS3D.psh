#define g_iNumLight  1

Texture2D g_txDiffuse : register(t0);
Texture2D g_txNormal : register(t1);
TextureCube g_txEniv : register(t2);
Texture2D g_txSpecular : register(t3);

SamplerState s0 : register(s0);

cbuffer cb0 : register(b0) // constant buffer name : register (empty : num)
{
	matrix	g_matView;
	matrix	g_matProj;
	float3	g_EyePos;
	float	width;
	float3	g_EyeDir;
	float	height;
};

cbuffer cb1 : register(b1) // constant buffer name : register (empty : num)
{
	matrix  g_InvMatrix;
	float4	g_Lightpos; // 월드 좌표xyz 거리w
	float4	g_LightDir; // 방향 xyz, 세기w
	float3	g_LightColor;
	float	g_fInner;	// 스팟의 내부콘
	float	g_fOutner;	// 스팟의 외부콘
	float	g_fOffset; // 원의 거리에 따른 감쇠에서의 오프셋
	int		g_iFlag;
	float	c1temd;
};

cbuffer cb1 : register(b2) // constant buffer name : register (empty : num)
{
	float3	m_ObjectColor;
	int		m_isDiffuse;
	int		m_isNormal;
	int		m_isSpecular;
	int		m_isOpacity;
	int		m_isReflection;
	int		m_isRefraction;
	int		m_isEnvironment;
};

struct PS3D_INPUT // 444 please
{
	float4 Position				: SV_POSITION;
	float3 UVPos				: TEXCOORD0;
	float3 Normal				: NORMAL;
	float3 WorldPosition		: POSITION0;
	float3 Reflect				: TEXCOORD1;
	float3 vLight[g_iNumLight]	: TEXCOORD2;
};

float3 ComputeLight(float3 Pos, float3 Normal)
{
	float3 LastColor = float3(0, 0, 0); // 결과값 초기화
	switch (g_iFlag)
	{
	case 0: // SPOT
	{
		float4 LightVector;
		LightVector.w = distance(Pos, g_Lightpos.xyz); // 거리체크
		if (LightVector.w > g_Lightpos.w) // 거리체크
		{
			break;
		}
		else if (LightVector.w > g_fOffset)
		{
			float fLuminance = smoothstep(g_Lightpos.w, g_Lightpos.w - g_fOffset, LightVector.w);
			LightVector.xyz = normalize(Pos.xyz - g_Lightpos.xyz); // 라이트벡터 방향 구하기
			float fDot = dot(Normal, -LightVector.xyz);
			LastColor.x += fDot * g_LightColor.x * fLuminance;
			LastColor.y += fDot * g_LightColor.y * fLuminance;
			LastColor.z += fDot * g_LightColor.z * fLuminance;
		}
		else
		{
			LightVector.xyz = normalize(Pos.xyz - g_Lightpos.xyz); // 라이트벡터 방향 구하기
			float fDot = dot(Normal, -LightVector.xyz);
			LastColor.x += fDot * g_LightColor.x;
			LastColor.y += fDot * g_LightColor.y;
			LastColor.z += fDot * g_LightColor.z;
		}
		break;
	}
	case 1: // SKY
	{
		float fDot = dot(Normal, -g_LightDir.xyz);
		LastColor.x += fDot * g_LightColor.x;
		LastColor.y += fDot * g_LightColor.y;
		LastColor.z += fDot * g_LightColor.z;
		break;
	}
	case 2: // DIRECT
	{
		break;
	}
	case 3: // OMNI
	{
		float3 vLight = normalize(Pos - g_Lightpos.xyz);
		float fDistance = distance(Pos, g_Lightpos.xyz);
		float fLuminance = smoothstep(fDistance - g_fOffset, fDistance, g_Lightpos.w);
		float3 normal = Normal;
		float fIntensity = saturate(dot(Normal, -vLight));
		LastColor += float3(g_LightColor.rgb *  fLuminance * fIntensity);
		break;
	}
	}
	LastColor = max(LastColor, float3(0, 0, 0));
	return LastColor;
}
float ComputeSpecular(float Intensity, float3 Normal, float3 Pos)
{
	float result;
	for (int i = 0; i < g_iNumLight; i++)
	{
		switch (g_iFlag)
		{
		case 0:	// SPOT
		{
			break;
		}
		case 1:	// SKY
		{
			float3	R = reflect(g_LightDir.xyz, Normal);
			result = saturate(dot(R, -g_EyeDir)).x;
			break;
		}
		case 2:	// DIRECT
		{
			break;
		}
		case 3:	// OMNI
		{
			float3 vLight = normalize(Pos - g_Lightpos.xyz);
			float3 R = reflect(vLight, Normal);
			result = saturate(dot(R, -g_EyeDir)).x;
			break;
		}
		}
	}
	return result * Intensity;


}

float NormalMapping(float3 LightVector, float3 NormalMapPixel)
{
	NormalMapPixel *= 2;
	NormalMapPixel -= 1;

	float fDot = dot(LightVector, NormalMapPixel);
	return fDot;
}

float4 PS(PS3D_INPUT data) : SV_TARGET
{
	//m_isDiffuse;
	//m_isNormal;
	//m_isSpecular;
	//m_isOpacity;
	//m_isReflection;
	//m_isRefraction;
	//m_isEnvironment;

	float4 lastcolor;
	if (m_isDiffuse == -1)
	{
		float4 Diffusecolor = g_txDiffuse.Sample(s0, data.UVPos.xy) * max(float4(0.1f, 0.1f, 0.1f, 1.0f), float4(ComputeLight(data.WorldPosition, data.Normal), 1));
		lastcolor = Diffusecolor;
	}
	else
	{
		float4 mutiplier = float4(0.3f, 0.3f, 0.3f, 1.0f) + float4(ComputeLight(data.WorldPosition, data.Normal), 1);
		lastcolor.xyz = m_ObjectColor * mutiplier.xyz;
	}
	if (m_isNormal == -1)
	{
		float4 Nomarlcolor = g_txNormal.Sample(s0, data.UVPos.xy);
		float normal = 0.0;
		for (int i = 0; i < g_iNumLight; i++)
		{
			normal += NormalMapping(data.vLight[i], Nomarlcolor.xyz);
		}
		lastcolor *= normal;
	}
	if (m_isSpecular != 0)
	{
		if(m_isSpecular == -1)
		{
			float4 SpecularColor = g_txSpecular.Sample(s0, data.UVPos.xy);
			float Specular = ComputeSpecular(SpecularColor.x, data.Normal, data.WorldPosition);
			lastcolor += Specular;
		}
		else
		{
			float Specular = ComputeSpecular(m_isSpecular / 255, data.Normal, data.WorldPosition);
			lastcolor += Specular;
		}
	}
	if (m_isEnvironment == -1)
	{
		float4 Enivcolor = g_txEniv.Sample(s0, data.Reflect);
		lastcolor = lerp(Enivcolor, lastcolor, 0.5);
	}
	if (m_isReflection == -1)
	{
		lastcolor.r = 1;
	}
	if (m_isRefraction == -1)
	{
		lastcolor.g = 1;
	}
	if (m_isEnvironment == -1)
	{
		lastcolor.b = 1;
	}
	if (m_isOpacity == -1)
	{

	}
	else
	{
		lastcolor.a = m_isOpacity / 255;
	}
	return lastcolor;
}
